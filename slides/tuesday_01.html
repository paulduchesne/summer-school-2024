

<!DOCTYPE html>
<html>
  <head>
    <title>Digital Summer School 2024: Tuesday Morning</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <link rel="stylesheet" href="../style.css">  </head>
  <body>
    <textarea id="source">

class: center, middle, titlepage
### TUE01: *Intro to Open Source, Command Line and FFmpeg*

---
class: center, middle, titlepage
### TUE01: *Open Source*
---
class: contentpage
### **Agenda 1**

Introduction to Open Source  
> 1.1 The four freedoms  
> 1.2 Source code  
> 1.3 Evaluating projects  
> 1.4 Support models  

---
class: contentpage
### **1. Introduction to Open Source**

Open source software is often thought of as free to use, but to be classified as Open a project must meet four criteria for its users.
---
class: contentpage
### **1.1 The Four Freedoms**

- __Freedom to run the programme how you like for any purpose__  

- __Freedom to study how the programme works, and make changes for your own use__  

- __Freedom to redistribute copies of the original programme to whoever you like__  

- __Freedom to redistribute copies of your modified version to whoever you like__  
  
An open source project should provide you with information about the type of licence that governs the use of it.  
Advice about open source licences can be found at the [Open Source Initiative](https://opensource.org/licenses)
---
class: contentpage
### **1.2 Source code**

You also need to access the source code. The licence will permit you to make your own copy of the software, to edit and redistribute. Mostly you‚Äôll find source code in Git repositories, like you see here for the FFmpeg libraries.  
  
.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/ffmpeg_source_code.png" width="1000">]

---
class: contentpage
### **1.3 Evaluating projects**  

1. Can you avoid adding it? Can you use existing dependencies or software already installed?  
   *Every new piece of software comes with dependencies and potential security issue.Answer: No, this piece of software is unique in how it losslessly compresses and preserves image sequences.*

2. Are you evaluating the correct version and not a fork of a project?  
   *There should be an official download site with the latest verion with links to their repositories. Check the website name is exactly correct and the project website link is correct.*  

3. If searching for a project, or following a recommendation, do you have the latest version of the software?  
   *Projects can move, as development teams or hosting shifts. Check the late release date and popularity of the repository. Recent releases and active users points to official released code.*

4. Is the project maintained? Has there been significant recent activity and version releases? Are they supporting user issues?
   *Take a look a the issues raised by users and whether they have been successfully resolved, and see how recent these conversations occurred.*

Further guidelines are available from the [Open Source Security Foundation](https://best.openssf.org/Concise-Guide-for-Evaluating-Open-Source-Software.html) 
---
class: contentpage
### **1.4 Support models**  

**Funded models**  

- Bounty driven development  
  _Independent developers receive bounty payments for feature development or bug fixes_  

- User support contracts  
  _Paid for support contracts help secure regular income for project developers_  

- Consulting or expertise  
  _Experienced developers charge for consultation work_  

- Mixed licensing  
  _Software offers free to use options, but others may require payment_  

- Grants and donations  
  _Payment for development of specific tools, grant funding or gifts_  


---
class: contentpage
### **1.4 Support models**  

**User support models**  
   
- Writing or editing documentation  
  _Save time for developers to work on code and not documentation_  

- Language translations  
  _Make the code more accessible for international users_  

- Supporting other users  
  _Peer to peer support saves developers time with basic enquiries_  

- Bug finding and testing software  
  _More user testing helps make the project more robust_  

- Promoting and fundraising  
  _Blogging about your use of software, helping raise money for developers_  

---
class: center, middle, titlepage
### TUE01: *Intro to the Command Line and Bash*
---
class: contentpage
### **Agenda 2**

Command Line Interface (CLI)   
> 2.1 Unix Terminal  
> 2.2 Windows Terminal, Command Prompt or PowerShell  
> 2.3 Unix tools on Windows  
> 2.4 Useful tools and commands  

Bash shell scripting 
> 2.5 Special characters and comparisons   
> 2.6 Loops and conditional statements  
> 2.7 Shebang and script formation  
> 2.8 Running and testing code

---
class: contentpage
### **2. Command Line Interface (CLI)**

The Command Line Interface is a text only window set into a Graphical User Interface (or GUI).

.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/2021-02-27_-_ffmpeg_version.gif" width="800">]
---
class: contentpage
### **2. Command Line Interface (CLI)**
 
A command is an instruction telling the computer how to act, like asking which FFmpeg version is installed  
```Bash
ffmpeg -version
```

A CLI has a command interpreter (or shell) running within it converting our typed command lines into a language the computer can understand  
  
As you type in a command (echo) with arguments ($SHELL) the shell interpreter reads and executes them  
```Bash
echo $SHELL
```

The CLI displays the command you type as well as the result of the command shown below
```Bash
/bin/bash
```
This example is asking the computer to print out which version of shell is being used by the CLI - eg Bash  
---
class: contentpage
### **2. Command Line Interface (CLI)**

.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/Parrot.gif" width="300">]
```bash
curl parrot.live
```

**Why would you want to use the command line?**

- To learn amazing new things like running Party Parrot!
- To install and run open source software   
- To use open source software projects that have limited or no graphical user interface  
- To run CPU intensive processes in the background while still running day to day software  
- To work remotely with servers or virtual machies over networks or in data centres  
- To build automated processes and operate more efficiently üëÄ  

---
class: contentpage
### **2.1 Linux and MacOS Terminal (Unix)**

Macintosh and Linux have the same operating system (OS) - Unix. There are many different Linux OS and all are open source, whereas MacOS is proprietary software developed by Apple.
  
UNIX operating systems all use a CLI called Terminal. To launch the Terminal in MacOS press the command and spacebar keys together then type Terminal into the search bar and a CLI windows will immediately launch.  
```Bash
Cmd + Space
``` 
To launch a Terminal CLI window in Linux OS press control, alt and the letter t at the same time.  
```Bash
Ctl + Alt + T
```
If you've checked what shell you're using and you want to change to Bash use the `chsh` command with the `-s` shell flag, followed by the argument `/bin/bash/`.  
```Bash
chsh -s /bin/bash
```
To check what version of Bash you are running you can use this command (the latest stable version is 5.2.32):  

```Bash
bash --version
```

---
class: contentpage
### **2.2 Windows Terminal, Command Prompt or PowerShell**

To launch a CLI in Windows Console click `Start`, and in the search type the name of the CLI you want to use and hit enter. The CLI will launch.
```Powershell
cmd (Command Prompt)   Powershell   Windows Terminal
```  
**Command Prompt (cmd or cmd.exe)**  
 The default CLI for older Windows Systems but includes Windows 9x and Windows NT. Generally Command Prompt only has a small variety of tools available to it.

**Powershell**  
Powershell is an automated command-line shell and also has all the features & functionalities of CMD. It has many more tools available and more advanced abilities for automation.  

**Windows Terminal**  
Windows 10 launched the Windows Terminal in 2019, which provides a choice of interpreters including:  
- `cmd.exe`  
- `Powershell`  
- `Windows Subsystem for Linux (WSL)`  

[Comparison of Command Shells](https://en.wikipedia.org/wiki/Comparison_of_command_shells) provides excellent comparisons of all the shells in use.  
---
class: contentpage
### **2.3 Unix tools on Windows**

Window Subsystem for Linux (WSL) v1 is supported in Windows 10, 11 and Windows Server 2016, 2019 and 2022. It does not allow access to all Unix tools, only those 'emulated' by the environment.  

WSL v2 allows installation of a full Linux distribution, eg Ubuntu, and so has all the same tools you'd find with a Linux OS. It is available in Windows 10 via the [Windows Insider Programme](https://learn.microsoft.com/en-us/shows/one-dev-minute/learn-how-to-install-wsl-2).  

If you are working on a Windows machine that doesn't have access to WSL then you can install and run two projects that provide CLI tools with similar functionality:

- [Cygwin](https://www.cygwin.com/) has a large collection of GNU and open source software tools that provide Unix like tools for Windows. It's compatible with x86_64 versions of Windows, from Windows 8.1 onward.

- [GNU On Windows (GOW)](https://github.com/bmatzelle/gow/wiki) is billed as a lightweight alternative to Cygwin, it contains over 100 'extremely useful open source UNIX applications' compiled as native win32 binaries. The package is just 18 MB in size, so useful if you have limited spaece.

---
class: contentpage
### **2.4 Useful commands and tools (Unix and Windows)**

Press the control button with the letters above to perform shell functions  
```Bash
Ctl+C | Ctl+A                 | Ctl+E               | Ctl+B                 | Ctl+F         | Ctl+H              | Ctl+D
Break | Move to start of line | Move to end of line | Backspace (no delete) | Forward space | Backspace (delete) | Log out of shell
```  
Start typing a path of file anem and use the tab button to autocomplete (supported in some shells including Bash)  
```Bash
Tab
```
Prints the name of the parent working directory to console  
```Bash
pwd (Unix) chdir (Windows)
```  
List the contents of the current directory you are in
```Bash
ls (Unix) dir (Windows)
```
Change directory by entering the name of a directory or using two dots to navigate up a directory  
```Bash
cd (Unix/Windows)
```
---
class: contentpage
### **2.4 Useful commands and tools (Unix and Windows)**

Create a new directory situated within the current parent directory 
```Bash
mkdir (Unix/Windows)
```
Create a `new_file.txt` situated with the current parent directory
```Bash
touch new_file.txt (Unix) type nul > new_file.txt (Windows)
```
Move a file or rename it by moving to a different name within the same path
```Bash
mv new_file.txt old_file.txt (Unix) move new_file.txt \path\new_file.txt (Windows)
```
Copy a file from one location to another relative or absolute path. You may be able to drag and drop a new folder location from your desktop to the CLI  
```Bash
cp new_file.txt /path/new_file.txt (Unix) copy new_file.txt \path\new_file.txt (Windows)
``` 
Clear the screen of previous command executions  
```Bash
clear (Unix) cls (Windows)
``` 
---
class: contentpage
### **2.4 Useful commands and tools (Unix)**

Echo will print a string, or variable contents to the CLI
```bash
echo "Hello World!"
```
Cat prints the contents of new_file.txt to the console  
```bash
cat new_file.txt
```  
Grep searches a given input file printing to the console any lines that match the supplied pattern, eg 'Search'  
```bash
grep "Search" new_file.txt
```
List the first ten lines only of the supplied file  
```Bash
head -10 new_file.txt
```
Works like head, but using the `-f` flag prints each new line out as it is written to the log
```Bash
tail -f script.log
```  
---
class: contentpage
### **2.4 Useful commands and tools (Unix) **

Basename, extracts the basename of a supplied path string whether it's a file or a directory  
```Bash
basename /mnt/path_to_file/folder  (returns folder)
basename /mnt/path_to_file/file.txt  (returns file.txt)
```
Dirname, extracts the directories in the path, except the last item whether it's a file or a directory  
```Bash
dirname /mnt/path_to_file/folder  (returns /mnt/path_to_file)
dirname /mnt/path_to_file/file.txt  (returns /mnt/path_to_file)
```
To retrieve the date now from your operating system you can use the date command below. You can format it to your preference using as shown here which returns YYYY-MM-DD - HH.MM.SS  
```bash
date "+%Y-%m-%d - %H.%M.%S"
```
rsync is a powerful program that copies files to/from a remote host, or locally. It uses remote-update protocol that just updates differences between two sets of files with an efficient checksum-search algorithm
```Bash
rsync -avh /path_one/file.txt path_two/file.txt
```
---
class: contentpage
### **2.4 Useful commands and tools (Unix) **

Manuals are available to help you better understand all these tools. To exit just press the letter `q` for quit  
```Bash
man basename
```
.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/man_basename.png" width="700">]

---
class: contentpage
### **2. Bash shell scripting**

A shell script is just a text file, with an extension .sh that contains the commands and tools you've already started using. When you place these commands into a shell script you can build more complex sequences of commands that follow a line by line sequence of execution from start to finish.

The Born Again SHell (Bash) succeeded the Born shell (sh) and is still the mostly widely used shell in use, particularly in Linux. Bash is very powerful as it can make certain complex operations run with ease, operations that would be impossible to complete with a GUI.

.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/Shell_example.png" width="800">]
---
class: contentpage
### **2.5 Special characters and comparisons**

Comments can be added anywhere, the hash symbol tells the interpreter not to read what follows
```Bash
#  -  #Comments here
```
Used to prefix variables to indicate to a script the value of that variable. `echo $?` returns the exit status   
```Bash
$  -  $var, echo $?
```
Indicates a placeholder used in a search command, or for concatenating variables in strings when prefixed with $   
```Bash
{}  -  ${PATH}
```
Tests are expressed between these square brackets. The double bracket is more flexible than the single bracket test. Single square brackets are also used for an array element (a large group of variables) 
```Bash
[] or [[]]  -  if [ -z "$var" ]
``` 
A semicolon allows you to concatenate two or more commands into one line completing each in turn  
```Bash
;  -  echo "Hello";  echo "lovely";  echo 'Archivists!'
```
---
class: contentpage
### **2.5 Special characters and comparisons**

The asterisk character serves as a 'wild card' and used on its own it matches all filenames in a given directory  
```Bash
*  -  find /path/folder/ -name '*.mkv'
```
The pipe `|` passes the standard output of a previous command, such as `echo` to the input of the next  
```Bash
|  -  echo "filename.txt" | rev | cut -c 5-  | rev
```
Two pipes together form the OR operator. This tries the first command and only if it receives a failure exit code will it try the next. The `&&` AND operator needs an exit code 0 (success) to continue processing commands in the chain        
```bash
||  &&   -  false || echo 'Hello World!'    false && echo "Hello World"
```
Single quotes `'` preserves all special characters in a string, but `"` quotes only preserve some of them. When quoting a variable `"$var"` always use double quotes which allow the variable to expand and reveal their content    
```Bash
"string" or 'string!'
```
Redirections are used to redirect the standard output (stdout) and standard errors (stderr) of a script into a file  
```Bash
>  &>  >>  &>>  -  echo 'Hello lovely Archivists!' >> test.log
```
---
class: contentpage
### **2.5 Special characters and comparisons**
These characters basically allow for arithmetic plus, minus and divide. % is the modulo, which returns the remainder of an arithmetic devision. Equals can be used in many ways, shown below  
```Bash
+  -  %  =
```
Single equals symbol below is being used to populate the `a` and `b` variables with strings. And in the `if` test two equals are used to check if variables `a` and `b` are the same. To check if two variables do not match, you would use the `is not equal` pair  
```Bash
a='string1'
b='string2'
if [ "$a" == "$b" ]
if [ "$a" != "$b" ]
```
To check if a numerical value is larger than another you can use the greater than `-gt >`,  or less than characters `-lt <` in a similar way. You would need to escape the arrow characters in single square brackets (they have another function to redirect outputs), so use double or opt for the `-gt` option instead.   
```bash
>  -gt    <  -lt    =  -eq
if [[ "$x" > "$y" ]]
if [ "$x" -gt "$y" ]
```
---
class: contentpage
### **2.6 Loops and conditional statements**

The find search has many arguments that help filter the results. When used with the `-exec` call it can loop through results performing the command that follows it. The escaped semicolon signals the end of the command
```Bash
find /mnt/path/folder -type f -name 'N_*' -exec mv {} /mnt/new_path/folder/{} \;
```
For loops will find files in the parent folder, using do and done to control the start and end of a loop.  Like the find loop, this example moves each found file '$f' to the relative path supplied until all have been processed  
```bash
for file in *.mov; do mv "$file" "/mnt/new_path/folder/${file}"; done
```
While loops will keep completing a set of tasks until the condition of the loop is no longer met. This example takes the $counter variable and while the number is `> 0` the command keeps minusing  `1`, (()) are integer expansions  
```bash
while [[ "$counter" > 0 ]]; do echo "${counter}"; counter=$(( counter - 1 )); done
```
If, elif, else, and fi make up a conditional construct. Ase we saw earlier, the if can execute execute a test, like is x greater than y. Depending on the exit code result the next command is decided. The `fi` signals that the conditional construct is complete  
```bash
if  elif   else   fi   then
```
---
class: contentpage
### **2.6 Loops and conditional statements**

.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/Shell_example.png" width="1200">]
---
class: contentpage
### **2.7 Shebang and script formation**

You can create a new shell script simply by making a file with the extension `.sh`

```Bash
touch new_script.sh
```

Then you can open that new file and type your script into it. To do this you can use several different tools, like `nano` `vim` or open it and edit in notepad or similar  
```bash
nano new_script.sh  (Ctl+X to exit)
vi new_script.sh    (Type :q to exit)
open new_script.sh  (Launches file in GUI)
```

Before you try to edit, save and run the script you need to ensure that the permissions of the file will allow you to edit, and later execute it. The chmod command modified file permissions  
```bash
chmod u+x new_script.sh
```
chmod u+x modifies the existing rights of a file for the user to read, write and execute. You can use `ls -l` to view the permissions of files in a folder  
---
class: contentpage
### **2.7 Shebang and script formation**

The shebang provides the path to the bash shell, and should be the first line of code so the shell knows to execute the script in bash shell. We found the shell path earlier using `echo $SHELL`    
```Bash
#! /bin/bash

# Note to say what script does
# Script to check if files in folder and print log to console and $LOG

# Create a variable for the path you want to search
PATH_TO_CHECK="/Users/Joanna/Desktop"

# Create a log variable and use touch to make the file
LOG="${PATH_TO_CHECK}/new_log.txt"
touch "${LOG}"

# Start the for loop searching for any file with an extension use the wild card
# Complete two commands for each file found, print 'Item found: name' to CLI and 
# append the name into the $LOG text file
for file in *.*
do
  echo "Item found: ${file}"
  echo "$file" >> "${LOG}"
done
```

---
class: contentpage
### **2.7 Shebang and script formation**

The same results but this time using the find loop, with a maxdepth setting of 1 to stop it searching in subfolders  
```Bash
#! /bin/bash

# Note to say what script does
# Script to check if files in folder and print log to console and $LOG

# Create a variable for the path you want to search
PATH_TO_CHECK="/home/usr/whitej/Desktop/folder"

# Create a log variable and use touch to make the file
LOG="${PATH_TO_CHECK}/new_log.txt"
touch "${LOG}"

# Start a for loop searching for any file with an extension use the wild card
# Set maxdepth to 1 to stop the search looking in subfolders and only find -type 'f', file
find "${PATH_TO_CHECK}" -maxdepth 1 -type f -name '*.*' -exec echo {} >> "${LOG}" \;  

```

[Shellcheck.net](https://shellcheck.net) is an excellent resource for testing your shell script is correctly formed before running it live 
---
class: contentpage
### **2.8 Running and testing code**

Make sure you have your permissions set to run the code, then just call it like the example below. This will launch the loop and print all the contents of your folder into a log file  
```Bash
./new_script.sh
```
To get better reporting on your file runs you can use some test commands that are placed into the script, right behind the shebang. `-x` uses Bash xtrace to print a trace of commands before and after they are executed within the script, `-v` increases verbosity of your script printing each line as written before executing  
```bash
#! /bin/bash -x -v
```
You can also use the `test` command which has lots of options for testing your bash commands. Full list of commands are available to view in the `man test`. This example is testing the command for return of a non-zero length string. The output of the test can be found using `echo $?`  
```bash
test -n "$(find "/User/Joanna/Desktop" -maxdepth 1 -type f -name '*.*' -exec echo {} \;)"
man test
```

POSIX is a standard that ensures shell scripts are portable between different Unix operating systems. If you think your code will need to be portable then it's worth reading more on POSIX bash compatibility:  
[GNU.org Bash-POSIX-Mode](https://www.gnu.org/savannah-checkouts/gnu/bash/manual/bash.html#Bash-POSIX-Mode)

---
class: center, middle, titlepage
### TUE01: *Intro to FFmpeg, FFprobe and FFplay*
---
class: contentpage
### **Agenda 3**

.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/FFmpeg_Logo_new.svg" width="600">]

Introduction to FFmpeg  
> 3.1 The FFmpeg libraries  
> 3.2 The basic FFmpeg command  
> 3.3 Useful audiovisual flags  
> 3.4 Encoding defaults    
> 3.5 FFprobe and FFplay  
> 3.6 Guides and help pages    

---
class: contentpage
### **Introduction to FFmpeg**
.left[<img src="https://raw.githubusercontent.com/digitensions/summer-school-2024-local/main/tuesday/images/FFmpeg_Logo_new.svg" width="600">]

- FFmpeg encodes, decodes, muxes and demuxes audiovisual file formats at speed  

- It has an extensive list of supported codecs and file formats  

- It's open source software and makes projects like VLC, YouTube and iTunes possible  

- Hundreds of filters that visualise and analyse complex audiovisual data  

- FFmpeg comes with a metadata analysis and extraction tool FFprobe  

- Playback of all FFmpeg formats and codecs and live streams is possible with FFplay  

- It can be used via the CLI, with third party GUIs or via their own API  
---

class: contentpage
### **3.1 The FFmpeg libraries**

- **libavutil**  
A library containing functions for simplifying programming, including random number generators, data structures, mathematic routines, core multimedia utilities and much more.  

- **libavcodec**  
A library containing decoders and encoders for audio and video codecs  

- **libavformat**  
A library containing demuxers and muxers for multimedia container formats  

- **libavdevice**  
A library containing input and output devices for grabbing from and rendering to many common multimedia software frameworks  

- **libavfilter**  
A Library containing many media filters  

- **libswscale**  
A library performing highly optimised image scaling and colour space / pixel format conversion  

- **libswresample**  
A library preforming optimised audio resampling, rematrixing and sample format conversions  
---
class: contentpage
### **3.2 The basic FFmpeg command**

This basic FFmpeg encoding command begins with calling the installed software `ffmpeg`. Following this you use the `-i` input flag followed by the path to your file.  Finally supply the path and filename of your new encoded file. If you have a file called `input.mov` this would convert it into an `mp4` version  
```bash
ffmpeg -i input.mov output.mp4
```
This is also the same for audio files, and image files  
```bash
ffmpeg -i input.wav output.mp3
ffmpeg -i input.tif output.jpg
```
To select a video or audio stream to change to a different encoding you can use the following flags. The first selects the video stream and indicates a ProRes codec, and the second selects the audio stream and uses the `copy` command so the audio remains the same  
```bash
ffmpeg -i input.mkv -c:v prores_ks output.mov
ffmpeg -i input.mkv -c:a copy output.mov
```
The input.mkv video will be re-encoded to ProRes in the first command, and the audio will be unchanged in the second command. But what happens to their other streams?  
---
class: contentpage
### **3.3 Encoding defaults**

It's important to know that if you do not select codec parameters carefully that FFmpeg will fall back to its default codec settings which are determined by the extension of the output file, so our previous examples will have audio changed to aac, and video to H.264!  

> **.avi**  default video mpeg4 - default audio mp3  

> **.mkv**  default video H.264 - default audio ac3    

> **.mov**  default video H.264 - default audio AAC   

> **.mp4**  default video H.264 - default audio AAC  

> **.mpg**  default video mpeg1video - default audio mp2   

> **.mxf**  default video mpeg2video - default audio pcm_s16le   

> **.wav**  default audio pcm_s16le (16 bit PCM)  


It's very important to specify exactly what codecs are wanted in the finished file  
```bash
ffmpeg -i input.mkv -c:v prores_ks -c:a pcm_s16le output.mov
```
---
class: contentpage
### **3.4 Useful audiovisual flags**

These commands always have a flag and an argument, and usually sit between the input file and the output file  

```bash
| flag / argument        | Description                                                     |  
|------------------------|-----------------------------------------------------------------|  
| -c:v codec_codec       | select video codec                                              |  
| -c:a audio_codec       | select audio codec                                              |  
| -map stream_choice     | maps specified streams to new file                              |  
| -vf video_filter       | select video filter                                             |  
| -af audio_filter       | select audio filter                                             |  
| -filter_complex        | selects filter for multiple inputs or outputs                   |  
| -pix_fmt yuv420p       | specifies chromasubsampling preferred for output                |  
| -crf 23                | numerical value for constant rate factor, lower = better, 0-51  |  
| -b:v 128k              | numerical value sets the bitrate of the output file             |  
| -f 25                  | sets the frames per second of the output file                   |  
| -aspect 4:3            | set the display aspect ratio                                    |  
| -colorspace bt709      | tags video with the specific colourspace                        |  
| -ss / -to 00:00:00.000 | set start/end timecode for editing duration of an output file   |  
| -flags +ildct          | use interlace aware discrete coside transform for interlacing   |
```

If you want to try an FFmpeg command in a for or while loop, you will want to add the `-nostdin` flag at the beginning, which blocks FFmpeg's default behaviour of receiving and acting on standard inputs
```bash
ffmpeg -nostdin -i input.mov...
```
---
class: contentpage
### **3.4 Useful audiovisual flags**

To run some experiments lets make a 10 second audiovisual file using FFmpeg lavfi filters as your inputs  
```basg
ffmpeg -f lavfi -i testsrc=size=1920x1080 -f lavfi -i "sine=frequency=1000:sample_rate=48000" -t 10 input.mov
```
You can trim video down to specific time code start and stops, and encode the output  
```bash
ffmpeg -ss 00:00:10.000 -i input.mov -to 00:00:25.000 -c:v libx264 -c:a aac output.mp4
```
You can export one thumbnails every frame between 1 and 2 seconds and save them as `png` files  
```bash
ffmpeg -i input.mov -vf select=`between(t,1,5)` -vsync 0 output_images%d.png 
```
Mute audio in a video file, between two time codes  
```bash
ffmpeg -i input.mov -c:v copy -af ‚Äúvolume=enable=‚Äòbetween(t,3,5)':volume=0" input_muted.mov
```
Convert an image sequence, such as your DPX sequence into a lossy ProRes 4:4:4 MOV file with framerate 25 fps 
```bash
cd <dpx_folder>
ffmpeg -f image2 -pattern_type glob -i ‚Äú*.dpx‚Äù -c:v prores_ks -profile:v 4 -pix_fmt yuv444p10le -r 25 your_dpx_file.mov
```
---
class: contentpage
### **3.5 FFprobe**

To extract metadata from a video file you can use FFprobe to retrieve it. This basic command will return your file's available technical metadata. The first gives you all the FFmpeg programme information but the second represses this information  
```bash
ffprobe input.mov
ffprobe -hide_banner input.mov
```
You can generate a much more specific command that allows you to just look at the file's video bitrate for example   
```bash
ffprobe -v error -select_streams v:0 -show_entries stream=bit_rate -of default=noprint_wrappers=1 input.mov
```
You can access lots of different data from your streams. To view all the metadata for a specific video stream (v:0 the first stream) you can use the -show_streams, -show_format flag, etc.    
```bash
-show_streams
-show_format
-show_packets
-show_frames
ffprobe -v error -select_streams v:0 -show_streams input.mov
```
---
class: contentpage
### **3.5 FFplay**

When an FFmpeg command allows you to save a video, FFplay allows you to stream it to a GUI windows and view the output. This uses the FFmpeg lavfi filter which can generate visual and audio contents to create test files  
```bash
ffmpeg -f lavfi -i testsrc=size=1024x576 -t 10 output.mov
ffplay -f lavfi -i testsrc=size=1024x576
```
You can play any file created by FFmpeg in FFplay, even when other players won't be able to. This is thanks FFplay using the same libraries used by FFmpeg to encode the file  
```bash
ffplay input.mov
ffplay input.jpg
ffplay input.wav
```
It is possible to use FFplay to preview video with overlaid filters that reveal certain information, like whether any of the pixels of the video are outside of broadcast safety levels  
```bash
ffplay -f lavfi "movie='input.mov', signalstats=out=brng:color=cyan[out]"
```
---
class: contentpage
### **3.6 Guides and help pages**

To find out more about FFmpeg look no further than their own manual (q to exit), help pages and their extensive lists of available codecs, formats, encoders, muxers, fitlers, etc.  
```bash
man ffmpeg
ffmpeg -h (long / full)
ffmpeg -version
ffmpeg -codecs
ffmpeg -formats
ffmpeg -muxers
ffmpeg -demuxers
ffmpeg -devices
ffmpeg -encoders
ffmpeg -decoders
ffmpeg -filters
```

[FFmpeg official website](https://ffmpeg.org)  
[FFmpeg bug tracker and Wiki pages](https://trac.ffmpeg.org/wiki)  
[FFmprovisor](https://amiaopensource.github.io/ffmprovisr/) from The Association of Moving Image Archivists  
[FFmpeg, FFprobe and FFplay training](https://training.ashleyblewer.com/) by Ashley Blewer  
[FFmpeg Cookbook for archivists](https://avpres.net/FFmpeg/) by Reto Kromer  
[Reading FFmpeg logs](https://www.youtube.com/watch?v=15ZUnR3Nx1k) by Ashley Blewer at No Time To Wait! 4  
---




    </textarea>
    <script src="https://remarkjs.com/downloads/remark-latest.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ratio: "16:9"});
    </script>
  </body>
</html>